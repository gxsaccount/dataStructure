## 查找二叉树  
**效率不平衡容易受影响**，引出平衡二叉查找树  
其他略  
## 平衡二叉查找树  
插入不平衡的解决：  
1.左左：左子树的左子树下插入新节点，自底向上，找到第一个失衡的节点右旋  
2.左右：左子树的右子树下新节点插入，将左右进行左旋，将左右先调整成左左，再右旋转  
3.右右跟左左一样，只需要旋转一次就能把树调整平衡，而左右跟右左也一样，都要进行旋转两次才能把树调整平衡  
左旋：  
![左旋](https://github.com/gxsaccount/dataStructure/blob/master/%E6%9F%A5%E6%89%BE%E6%A0%91%E5%9B%BE%E7%89%87/rotateLeft.gif)   
右旋：  
![右旋](https://github.com/gxsaccount/dataStructure/blob/master/%E6%9F%A5%E6%89%BE%E6%A0%91%E5%9B%BE%E7%89%87/rotateRight.gif)  
删除不平衡的解决：  
1.叶节点删除，从父节点开始找失衡，判断失衡类型旋转  
2.删除的节点只有一个子树，将子树替换节点，从父节点开始找失衡，判断失衡类型旋转  
3.删除的节点只有两个子树，中序遍历，找到删除节点的下一个，替换删除节点，从父节点开始找失衡，判断失衡类型旋转  
**AVL树的插入和删除都很容易破坏平衡性。**引出2-3树  

## 2-3树  
2-3树运行每个节点保存1个或者两个的值。  
2节点保存一个key，左子树小于key，右子树大于key。  
3节点保存2个key。左子树小于key，中子树介于两个key之间，右子树大于大key。 
查找：先比较中键，找对应所在子树  
插入：  
未命中的查找结束于2-结点，把这个2-结点替换为一个3-结点，将要插入的键保存在其中  
未命中的查找结束于3-结点，临时插入变为4节点，再分裂，将中间元素移动到父节点，依次递归操作父节点。  
2-3树插入算法**变换有局部性**，变换时除了相关节点和链接之外，不用改变树的其他部分。  
**统计上的效率优于AVL树**：比起AVL树，2-3树的平衡性不易被破坏，2节点插入变成3节与3节点删除变成2节点不会让树失去平衡。  
## 红黑树：  
2-3树的一种实现：  
与2-3树的转化  
红色链接：3节点，连接两个2-nodes节点来表示  
黑色链接：连接普通的2-3节点。  
红黑树的另一种定义是满足下列条件的二叉查找树：  
⑴**红链接均为左链接**。（保证2-3的键值升序，右连接也可以，但是情况和代码量多很多）  
⑵没有任何一个结点同时和两条红链接相连。（2-3树的节点key最多2个）  
⑶该树是**完美黑色平衡**的，即任意空链接到根结点的路径上的黑链接数量相同。（因为2-3的平衡）  
红黑树和2-3树转化  
![红黑树和2-3树转化](https://github.com/gxsaccount/dataStructure/blob/master/%E6%9F%A5%E6%89%BE%E6%A0%91%E5%9B%BE%E7%89%87/%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8E2-3%E6%A0%91%E8%BD%AC%E5%8C%96.jpg)  
插入：  
插入节点先设为红节点，保证2-3的键值升序，调整红节点为左链接，若需要分裂3节点则分裂。然后递归向上操作。   
2节点添加：  
![2节点添加](https://github.com/gxsaccount/dataStructure/blob/master/%E6%9F%A5%E6%89%BE%E6%A0%91%E5%9B%BE%E7%89%87/2%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E6%96%B0%E5%BB%BA.jpeg)
3节点添加：  
![3节点添加](https://github.com/gxsaccount/dataStructure/blob/master/%E6%9F%A5%E6%89%BE%E6%A0%91%E5%9B%BE%E7%89%87/3%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE.jpeg)  
删除：  
1.当被删除元素为红时，直接删除（不会影响黑色的平衡性）。   
2.当被删除元素为黑且为根节点时，直接删除。   
3.当被删除元素为黑，且有一个右子节点为红时，将右子节点涂黑放到被删除元素的位置。（对应2-3树的3节点变2节点）    
4.当被删除元素为黑，且兄弟节点为黑，兄弟节点两个孩子也为黑，父节点为红，此时，交换兄弟节点与父节点的颜色；NIL元素是指每个叶节点都有两个空的，颜色为黑的NIL元素，需要他的时候就可以把它看成两个黑元素，不需要的时候可以忽视他。   
5.当被删除元素为黑、并且为父节点的左支，且兄弟颜色为黑，兄弟的右支为红色，这个时候需要交换兄弟与父亲的颜色，并把父亲涂黑、兄弟的右支涂黑，并以父节点为中心左转。  
6.当被删除元素为黑、并且为父节点的左支，且兄弟颜色为黑，兄弟的左支为红色，这个时候需要先把兄弟与兄弟的左子节点颜色互换，进行右转，然后就变成了规则5一样了，在按照规则5进行旋转。 

用红黑树或2-3树做索引时，因为节点键值不多，所以磁盘会频繁的io，影响性能，所以引出b树    
## B树  
B树上大部分的操作所需的磁盘存取次数与B树的高度是成正比的。  
B树可以看作2-3树的扩展，它允许每个节点有M-1个子节点。B+树则是B树的扩展。  
•	根节点至少有两个子节点（限制树不要太深）  
•	每个节点有M-1个key（保证一个节点查找效率），并且以升序排列（自身性质）  
•	位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间（自身性质）  
•	其它节点至少有M/2个子节点（限制树不要太深）  
• 所有叶子节点位于同一层（平衡性质）   
b树例子：
![b树例子](https://github.com/gxsaccount/dataStructure/blob/master/%E6%9F%A5%E6%89%BE%E6%A0%91%E5%9B%BE%E7%89%87/b%E6%A0%91.png)  
插入：
B树节点的插入，可以类比2-3-4树，即，若节点插入节点的key还未“丰满”，则直接插入，若节点插入节点的key已“丰满”，则插入节点之后分裂，再以分裂之后的父节点看作向上层插入的节点调整，直至满足该 m 阶的B树。  
![b树添加](https://github.com/gxsaccount/dataStructure/blob/master/%E6%9F%A5%E6%89%BE%E6%A0%91%E5%9B%BE%E7%89%87/b%E6%A0%91%E6%8F%92%E5%85%A5.gif)
删除：  
（1）若删除非叶子节点，找后继节点替换之，将问题转化为删除叶子节点；  
（2）若删除叶子节点，且叶子节点的key数大于定义中的最小值（根节点至少有1个key，非根节点至少有 Math.ceil(m/2)-1 个key），则直接删除即可，无需调整，  
（3）若删除叶子节点，且叶子节点的key数刚好满足定义中的最小值，即刚好“脱贫”，则将节点删除，此时树肯定需要调整，即：  
　a.若删除节点的相邻兄弟节点的key数“富裕”（节点的key大于定义中的最小值），则父节点的1个key下移与待删除的节点合并，相邻兄弟节点的1个key上移与父节点合并，完成调整；  
　b.若删除节点的相邻兄弟节点的key数刚好“脱贫”（节点的key刚好满足定义的最小值），则父节点的1个key下移与待删除的节点及相邻兄弟节点，三者进行合并成一个节点，若下移1个key后的父节点的key数刚好“脱贫”或“富裕”，则调整完成，反之，即此时父节点已经陷入“贫穷”，则将父节点看作当前待删除的节点，重复a，b的判断。  
 ![b树删除](https://github.com/gxsaccount/dataStructure/blob/master/%E6%9F%A5%E6%89%BE%E6%A0%91%E5%9B%BE%E7%89%87/b%E6%A0%91%E5%88%A0%E9%99%A4.gif)

    
B树的非叶子节点包含信息，读取非叶子节点时，冗余信息太多，所以引出b+树，  
## B+树：  
B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。  
B+树例子：
![B+树例子](https://github.com/gxsaccount/dataStructure/blob/master/%E6%9F%A5%E6%89%BE%E6%A0%91%E5%9B%BE%E7%89%87/b%2B%E6%A0%91.png)
B+ 树的优点在于：  
•	由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。  
•	B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。  
但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。下面是B 树和B+树的区别
  
搜索：略  
插入：  
删除：  

