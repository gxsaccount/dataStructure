## 查找二叉树  
**效率不平衡容易受影响**，引出平衡二叉查找树  
其他略  
## 平衡二叉查找树  
插入不平衡的解决：  
1.左左：左子树的左子树下插入新节点，自底向上，找到第一个失衡的节点右旋  
2.左右：左子树的右子树下新节点插入，将左右进行左旋，将左右先调整成左左，再右旋转  
3.右右跟左左一样，只需要旋转一次就能把树调整平衡，而左右跟右左也一样，都要进行旋转两次才能把树调整平衡  
删除不平衡的解决：  
1.叶节点删除，从父节点开始找失衡，判断失衡类型旋转  
2.删除的节点只有一个子树，将子树替换节点，从父节点开始找失衡，判断失衡类型旋转  
3.删除的节点只有两个子树，中序遍历，找到删除节点的下一个，替换删除节点，从父节点开始找失衡，判断失衡类型旋转  
**删除节点时有可能因为失衡，导致需要从删除节点的父节点开始，不断的回溯到根节点，如果这棵平衡二叉树很高的话，那中间就要判断很多个节点。**引出2-3树  
![左旋](https://github.com/gxsaccount/dataStructure/blob/master/rotateLeft.gif) 
![右旋](https://github.com/gxsaccount/dataStructure/blob/master/rotateRight.gif)
![b树删除](https://github.com/gxsaccount/dataStructure/blob/master/b%E6%A0%91%E5%88%A0%E9%99%A4.gif)
![b树添加](https://github.com/gxsaccount/dataStructure/blob/master/b%E6%A0%91%E6%8F%92%E5%85%A5.gif)
![2节点添加](https://github.com/gxsaccount/dataStructure/blob/master/2%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E6%96%B0%E5%BB%BA.jpeg)
![3节点添加](https://github.com/gxsaccount/dataStructure/blob/master/3%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE.jpeg)

##2-3树  
2-3树运行每个节点保存1个或者两个的值。  
2节点保存一个key，左子树小于key，右子树大于key。  
3节点保存2个key。左子树小于key，中子树介于两个key之间，右子树大于大key。  
查找：先比较中键，找对应所在子树  
插入：  
未命中的查找结束于2-结点，把这个2-结点替换为一个3-结点，将要插入的键保存在其中  
未命中的查找结束于3-结点，临时插入变为4节点，再分裂，将中间元素移动到父节点，依次递归操作父节点。  
2-3树插入算法**变换有局部性**:  
除了相关的结点和链接之外不必修改或者检查树的其他部分。每次变换中，变更的链接数量不会超过一个很小的常数。所有局部变换都不会影响整棵树的有序性和平衡性。  
2-3树在最坏情况下仍有较好的性能。每个操作中处理每个结点的时间都不会超过一个很小的常数，且这两个操作都只会访问一条路径上的结点，所以任何查找或者插入的成本都肯定不会超过对数级别。  
我们需要维护两种不同类型的结点，查找和插入操作的实现需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。  
平衡一棵树的初衷是为了消除最坏情况，但我们希望这种保障所需的代码能够越少越好。  

## 红黑树：  
2-3树的一种实现：  
与2-3树的转化  
红色链接：3节点，连接两个2-nodes节点来表示  
黑色链接：连接普通的2-3节点。  
红黑树的另一种定义是满足下列条件的二叉查找树：  
⑴红链接均为左链接。（保证2-3的键值升序）  
⑵没有任何一个结点同时和两条红链接相连。（2-3树的节点key最多2个）  
⑶该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。（因为2-3的平衡）  
插入：  
插入节点先设为红节点，保证2-3的键值升序，调整红节点为左链接，若需要分裂3节点则分裂。然后递归向上操作。 

红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。  
平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。  
用红黑树或2-3树做索引时，因为节点键值不多，所以磁盘会频繁的io，影响性能，所以引出b树  
## B树  
B树上大部分的操作所需的磁盘存取次数与B树的高度是成正比的。  
B树可以看作2-3树的扩展，它允许每个节点有M-1个子节点。B+树则是B树的扩展。  
•	根节点至少有两个子节点（限制树不要太深）  
•	每个节点有M-1个key（保证一个节点查找效率），并且以升序排列（自身性质）  
•	位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间（自身性质）  
•	其它节点至少有M/2个子节点（限制树不要太深）  
• 所有叶子节点位于同一层（平衡性质）   
插入：
B树节点的插入，可以类比2-3-4树，即，若节点插入节点的key还未“丰满”，则直接插入，若节点插入节点的key已“丰满”，则插入节点之后分裂，再以分裂之后的父节点看作向上层插入的节点调整，直至满足该 m 阶的B树。
删除：
（1）若删除非叶子节点，找后继节点替换之，将问题转化为删除叶子节点；

（2）若删除叶子节点，且叶子节点的key数大于定义中的最小值（根节点至少有1个key，非根节点至少有 Math.ceil(m/2)-1 个key），则直接删除即可，无需调整，

（3）若删除叶子节点，且叶子节点的key数刚好满足定义中的最小值，即刚好“脱贫”，则将节点删除，此时树肯定需要调整，即：

　a.若删除节点的相邻兄弟节点的key数“富裕”（节点的key大于定义中的最小值），则父节点的1个key下移与待删除的节点合并，相邻兄弟节点的1个key上移与父节点合并，完成调整；

　b.若删除节点的相邻兄弟节点的key数刚好“脱贫”（节点的key刚好满足定义的最小值），则父节点的1个key下移与待删除的节点及相邻兄弟节点，三者进行合并成一个节点，若下移1个key后的父节点的key数刚好“脱贫”或“富裕”，则调整完成，反之，即此时父节点已经陷入“贫穷”，则将父节点看作当前待删除的节点，重复a，b的判断。
    
    
B树的非叶子节点包含信息，读取非叶子节点时，冗余信息太多，所以引出b+树，  
## B+树：  
B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。  
B+ 树的优点在于：  
•	由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。  
•	B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。  
但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。下面是B 树和B+树的区别
  
搜索：略  
插入：  
  
删除：  

